<!DOCTYPE html><html lang="kr"><head><meta charSet="utf-8"/><link rel="preload" as="font" href="/_next/static/media/c9a5bc6a7c948fb0-s.p.woff2" crossorigin="" type="font/woff2"/><link rel="stylesheet" href="/_next/static/css/efb8fa6fa0f88240.css" data-precedence="next"/><link rel="preload" href="/_next/static/chunks/webpack-b095ed2a5c5bf76b.js" as="script"/><link rel="preload" href="/_next/static/chunks/fd9d1056-5fc0659828b82348.js" as="script"/><link rel="preload" href="/_next/static/chunks/596-5f69a5936ae99734.js" as="script"/><link rel="preload" href="/_next/static/chunks/main-app-e8cf5a024458e18b.js" as="script"/><title>Create Next App</title><meta name="description" content="Generated by create next app"/><meta name="viewport" content="width=device-width, initial-scale=1"/><link rel="icon" href="/favicon.ico" type="image/x-icon" sizes="16x16"/><meta name="next-size-adjust"/><script src="/_next/static/chunks/polyfills-78c92fac7aa8fdd8.js" noModule=""></script></head><body class="__className_e66fe9"><div class="w-full flex flex-col items-center p-3"><header class="w-full max-w-3xl flex flex-row justify-between items-center my-1"><a class="flex flex-row items-center" href="/"><img alt="로고" loading="lazy" width="30" height="30" decoding="async" data-nimg="1" class="rounded-full" style="color:transparent" src="/logo.png"/><span class="mx-2 font-semibold text-lg">jiohh blog</span></a><nav><a class="mr-5 " href="/">Home</a><a class="mr-5 " href="/blog">Blog</a><a class="mr-5 " href="/category">Category</a></nav></header><main class="w-full max-w-3xl"><div class="mt-10 prose"><h1 class="">4장 - 처리율 제한 장치의 설계</h1><h2>목표</h2>
<p>처리율 제한 장치 : 클라이언트 또는 서비스가 보내는 트래픽의 처리율을 제어하기 위한 장치<br/>
<!-- -->임계치를 넘어선 호출의 경우 처리가 중단(block)된다.</p>
<p>처리율 제한 장치의 사용에 대한 장점</p>
<ul>
<li>Dos공격에 의한 자원 고갈을 방지 할 수 있다.</li>
<li>비용을 절감한다. 서버를 많이 두지 않아도되고 우선 순위가 높은 API에 대한 더 많은 자원을 할당할 수 있다.<br/>
<!-- -->API를 사용하고 있는 서비스의 경우 횟수 제한으로 인한 비용절감 효율이 증가한다.</li>
<li>서버 과부하를 막는다. bot에서 오는 트래픽, 사용자의 잘못된 이용으로 인한 트래픽을 줄임으로 과부하를 막는다.</li>
</ul>
<p>이러한 처리율 제한 장치 설계에 대해 알아보자</p>
<h2>1단계 문제 이해 및 설계 범위 확정</h2>
<p>면접관과 소통을 통해 어떤 제한 장치를 구현해야 하는지 분명히 함으로 <strong>처리율 제한 장치의 알고리즘을 선택</strong> 할 수 있다.</p>
<p>다음 시스템 요구사항을 얻어낼 수 있다.</p>
<ul>
<li>설정된 처리율을 초과하는 요청은 정확하게 제한한다.</li>
<li>낮은 응답시간 : 처리율 제한 장치로 HTTP 응답시간에 영향을 주어서는 곤란하다.</li>
<li>메모리는 가능한 적게 사용</li>
<li>분산형 처리율 제한 : 처리율 제한 장치를 여러서버나 프로세스에서 공유할 수 있어야 한다.</li>
<li>예외처리 : 요청이 제한되었을때 사용자에게 분명히 보여주어야 한다.</li>
<li>높은 결함 감내성 : 제한 장치에 장애가 생기더라도 전체 시스템에 영향을 주어서는 안된다.</li>
</ul>
<h2>2단계 개략적 설계안 제시 및 동의 구하기</h2>
<h3>처리율 제한 장치는 어디에 둘 것인가?</h3>
<h4>클라이언트</h4>
<p>클라이언트 요청은 쉽게 위변조가 가능해 처리율 제한을 안정적으로 걸 수 있는 환경이 아님</p>
<h4>서버</h4>
<ol>
<li>API 서버가 처리율 제한 장치역할을 같이하는 경우</li>
<li>처리율 제한 미들웨어를 만들어 API서버로 가는 요청을 통제하도록하는 경우
클라우드 마이크로서비스의 경우 해당 방식은 보통 API 게이트웨이라 불리는 컴포넌트에 구현</li>
</ol>
<p>처리율 제한 장치는 어디에 두어야하는 것에 정답은 없다. 기술스택, 인력, 우선순위, 목표에 따라 달라진다.</p>
<ul>
<li>기술 스택을 점검하라. 현재 사용하는 프로그래밍 언어가 서버 측 구현을 지원하기 충분할 정도로 효율이 높은지 확인하라.</li>
<li>필요에 맞는 처리율 제한 알고리즘을 찾아라, 서버에서 구현한다면 선택가능하나 제 3 사업자가 제공하는 게이트웨이를 사용하면 선택지는 제한된다.</li>
<li>마이크로서비스에 기반하고 있고, 사용자 인증/IP 허용목록 관리 등의 처리로 API 게이트웨이를 설계에 포함시켰다면 처리율 제한 기능도 게이트 웨이에 포함시켜야 할 수도 있다.</li>
<li>처리율 제한 서비스는 직접 만드는데 시간이 든다, 사용 API 게이트웨이를 쓰는 것이 바람직 할 수도 있다.</li>
</ul>
<h3>처리율 제한 알고리즘</h3>
<h4>토큰 버킷 알고리즘</h4>
<p>간단한 알고리즘으로 보편적으로 사용한다. 아마존,스트라이프에서 사용</p>
<p>토큰 버킷은 지정된 용량을 갖는 컨테이너이며 사전 설정된 양의 토큰이 주기적으로 채워진다.</p>
<p>각 요청은 처리 될때마다 하나의 토큰을 사용한다</p>
<ul>
<li>충분한 토큰이 있는 경우 하나의 토큰을 꺼낸 후 요청을 시스템에 전달</li>
<li>충분한 토큰이 없는 경우 해당 요청은 버려짐</li>
</ul>
<img src="/images/LSS/bucketargo.png" width="100%" height="100%"/>
<p>두개의 인자를 받는다.</p>
<ul>
<li>버킷 크기 : 버킷에 담을 수 있는 토큰의 최대 개수</li>
<li>토큰 공급률 : 초당 몇 개의 토큰이 버킷에 공급되는가?</li>
</ul>
<p>버킷은 몇 개나 사용해야하는지는 공급 제한 규칙에 따라 달라진다.</p>
<ul>
<li>통상적으로, API 엔드포인트마다 별도의 버킷을 둔다.<br/>
<!-- -->ex) 하루에 한번 포스팅, 친추추가는 150명까지, 좋아요는 다섯번 ➡️ 사용자마다 3개의 버킷 필요</li>
<li>IP 주소별로 처리율 제한 ➡️ IP주소마다 버킷</li>
<li>시스템 처리율을 초당 10,000개 요청 제한하고 싶으면, 모든 요청이 하나의 버킷을 공유</li>
</ul>
<p>장점</p>
<ul>
<li>구현이 쉬움</li>
<li>메모리 사용 측면에서 효율적</li>
<li>짤은 시간에 집중되는 트래픽에서도 처리 가능</li>
</ul>
<p>단점</p>
<ul>
<li>버킷크기와 토큰 공급률을 적당한 값에 맞추는 것이 어려움</li>
</ul>
<h4>누출 버킷 알고리즘</h4>
<p>토큰 버킷 알고리즘과 비슷 - 요청 처리율이 고정되어 있음<br/>
<!-- -->FIFO큐로 구현한다.</p>
<img src="/images/LSS/leakybucket.png" width="100%" height="100%"/>
<ul>
<li>요청이 도착하면 큐가 가득 차있는지 확인 후, 빈자리가 있는 경우 큐에 넣는다.</li>
</ul>
<p>두 개의 인자를 사용한다.</p>
<ul>
<li>버킷 크기 : 큐 사이즈와 같은 값</li>
<li>처리율 : 지정된 시간당 몇 개의 항목을 처리할지 지정하는 값, 초 단위로 표현</li>
</ul>
<p>장점</p>
<ul>
<li>큐의 크기가 제한되어 있어 메모리 사용량 측면에서 효율적</li>
<li>고정된 처리율을 갖고 있기 때문에 안정적 출력에 적합</li>
</ul>
<p>단점</p>
<ul>
<li>단시간에 트래픽이 몰리는 경우, 오래된 요청이 쌓여 최신요청들은 버려지게됨</li>
<li>두개의 인자 설정이 어려움</li>
</ul>
<h4>고정 윈도 카운터 알고리즘</h4>
<ul>
<li>타임라인을 고정된 간격의 윈도로 나누고, 각 윈도우 마다 카운터(counter)를 붙인다.</li>
<li>요청이 접수될 때마다 이 카운터의 값은 1씩 증가한다.</li>
<li>카운터의 값이 임계치에 도달하면 새로운 요청은 새 윈도가 열릴 때까지 버려진다.</li>
</ul>
<img src="/images/LSS/fixed-window-counter.png" width="100%" height="100%"/>
<ul>
<li>해당 시스템은 초당 3개까지의 요청만 허용한다.</li>
</ul>
<img src="/images/LSS/fixed-window-counter-problem.png" width="100%" height="100%"/>
<ul>
<li>초당 5개의 요청만 허용하는 시스템</li>
<li>2:00:00 ~ 2:01:00 5개의 요청</li>
<li>2:01:00 ~ 2:02:00 5개의 요청</li>
<li>그러나 윈도우를 조금 옮겨 2:00:30 ~ 2:01:30으로 보았을 떄 10개의 요청이 처리됨</li>
</ul>
<p>윈도의 경계 부근에 순간적으로 많은 트래픽이 집중될 경우 윈도에 할당된 양보다 더 많은 요청이 처리될 수 있다.</p>
<p>장점</p>
<ul>
<li>메모리 효율이 좋다</li>
<li>이해하기 쉽다.</li>
<li>윈도우가 닫히는 시점에 카운터 초기화 ➡️ 특정한 트래픽 패턴을 처리하기에 적합</li>
</ul>
<p>단점</p>
<ul>
<li>경계부분에 몰릴 경우, 시스템의 처리 한도보다 많은 양의 요청을 처리하게 된다.</li>
</ul>
<h4>이동 윈도 로깅 알고리즘</h4>
<p>이동 윈도 알고리즘은 고정 윈도 카운터 알고리즘의 경계 부근의 트래픽 집중 문제를 해결한다.<br/>
<!-- -->요청의 타임스탬프를 추적하는 방식을 사용한다. 타임스탬프 데이터는 보통 Redis의 정렬 집합 같은 캐시에 보관한다.</p>
<img src="/images/LSS/sliding-window-log.png" width="100%" height="100%"/>
<ul>
<li>새요청이 오면 만료된 타임스탬프는 제거한다. 만료된 타임스탬프는 그 값이 현재
윈도의 시작 지점보다 오래된 타임스탬프를 말한다.</li>
<li>새요청의 타임스탬프를 로그에 추가한다.</li>
<li>로그의 크기가 허용치보다 크면 처리를 거부한다.</li>
</ul>
<p>장점</p>
<ul>
<li>어느 순간의 윈도를 보더라도, 허용되는 요청의 개수는 시스템의 처리율 한도를 넘지 않는다.</li>
</ul>
<p>단점</p>
<ul>
<li>다량의 메모리 사용, 거부된 요청의 타임스탬프도 보관하기 때문이다.</li>
</ul>
<h4>이동 윈도 카운터 알고리즘</h4>
<p>고정 윈도 카운터 알고리즘 + 이동 윈도 로깅 알고리즘 = 이동 윈도 카운터 알고리즘</p>
<img src="/images/LSS/sliding-window-counter.png" width="70%" height="100%"/>
<p>분당 7개의 요청 한도에서, 이전 1분동안 5개의 요청, 현재 1분 동안 3개의 요청이 오는 상황이다.</p>
<p>현재 1분의 30% 기점에 도착한 새 요청의 경우, 현재 윈도에 몇 개의 요청이 온 것으로 보고 처리해야할까?</p>
<ul>
<li>현재 1분간 요청 수 + 직전 1분간 요청수 * 이동 윈도와 직전 1분이 겹치는 비율</li>
<li>3 + 5 * 70% = 6.5, 내림하여 6</li>
</ul>
<p>장점</p>
<ul>
<li>이전 시간대의 평균 처리율에 따라 현재 윈도의 상태를 계산하므로 짧은 시간에 몰리는 트래픽에도 잘 대응</li>
<li>메모리 효율이 좋다.</li>
</ul>
<p>단점</p>
<ul>
<li>직전 시간대에 도착한 요청이 균등하게 분포되어 있다고 가정한 상태에서 추정치를 계산하기 때문에 다소 느슨하다.(잘못된 처리 0.003%로 심각하지 않음)</li>
</ul>
<h4>개략적인 아키텍쳐</h4>
<p>기본 아이디어는 추적할 수 있는 카운터를 추적 대상별로 두고 거부또는 허가하는 것이다.
이때 카운터에는 디스크 접근 떄문에 느리기 때문에 메모리 상에서 동작하는 Redis와 같은 메모리 기반 저장장치를 사용한다.</p>
<p>메모리 기반 저장장치는 두개의 명령어를 지원한다.</p>
<ul>
<li>INCR : 메모리의 저장된 카운터의 값을 1만큼 증가시킨다.</li>
<li>EXPIRE : 카운터에 타임아웃 값을 설정한다. 설정시간이 되면 카운터는 자동으로 삭제된다.</li>
</ul>
<img src="/images/LSS/Redis.png" width="100%" height="100%"/>
<ul>
<li>요청이 오면 처리율 제한 미들웨어는 레디스의 지정 버킷에서 카운터를 가져와 한도에 도달했는지 아닌지를
검사한다.</li>
<li>한도에 도달하지 않았다면 요청은 API서버로 전달된다. 미들웨어는 카운터의 값을 증가시킨 후 다시 레디스에 저장한다.</li>
</ul>
<h2>상세 설계</h2>
<ul>
<li>처리율 제한 규칙은 어떻게 만들어지고 어디에 저장되는가?</li>
<li>처리가 제한된 요청들은 어떻게 처리되는가?</li>
</ul>
<p>위의 두 사항에 대해 알아보자</p>
<h3>처리율 제한 규칙</h3>
<ul>
<li>마케팅 메시지의 최대치를 하루 5개로 제한</li>
<li>분당 로그인 횟수를 5개로 제한</li>
</ul>
<p>리프트의 경우 다음과 같이 제한하며, 설정파일 형태로 디스크에 저장된다.</p>
<h3>처리율 한도 초과 트래픽</h3>
<p>한도 제한에 거릴 경우 HTTP 429 응답을 보낸다.</p>
<ul>
<li>X-Ratelimit-Remaining : 윈도 내에 남은 처리 가능 요청의 수</li>
<li>X-Ratelimit-Limit : 매 윈도마다 클라이언트가 전송할 수 있는 요청의 수</li>
<li>X-Ratelimit-Retry-After : 한도 제한에 걸리지 않으려면 몇 초 뒤에 요청을 다시 보내야하는지 알림</li>
</ul>
<p>자기 요청이 처리율 제한에 걸리기까지 얼마나 많은 요청을 보낼 수 있는지는 HTTP 요청헤더로 확인 가능하다.</p>
<h3>상세 설계</h3>
<img src="/images/LSS/detail.png" width="100%" height="100%"/>
<p>다음은 상세 설계 도면이다.</p>
<h3>분산 환경에서의 처리율 제한 장치의 구현</h3>
<p>경쟁조건, 동기화 두가지 문제를 풀어야한다.</p>
<h4>경쟁조건</h4>
<img src="/images/LSS/trace.png" width="100%" height="100%"/>
<p>경쟁 조건 문제를 해결하는 가장 널리 알려진 해결책은 Lock(락)이다.
하지만 락은 시스템 성능을 떨어뜨림, 해결책으로는 두가지 방법이 있음</p>
<ul>
<li>루아 스크립트</li>
<li>정렬집합이라 불리는 레디스 자료구조</li>
</ul>
<h3>동기화 이슈</h3>
<p>처리율 제한 장치를 여러 대 두게 되면 동기화가 필요해진다.<br/>
<!-- -->장치간의 처리율 제한에 대한 정보가 공유되지않아 올바르게 수행 할 수 없다.</p>
<img src="/images/LSS/center-redis.png" width="100%" height="100%"/>
<p>레디스와 같은 중앙 집중형 데이터 저장소를 쓰는 것으로 해결</p>
<h3>성능 최적화</h3>
<ol>
<li>edge server을 이용하여 가까운 데이터센터를 지원하여 지연시간을 줄임으로 성능 최적화</li>
<li>제한 장치 간에 데이터를 동기화 할때 최종 일관성 모델을 사용</li>
</ol>
<h3>모니터링</h3>
<p>모니터링을 통해 알고리즘, 제한 규칙이 효과적인지 확인할 수 있다.</p>
<h2>4단계 마무리</h2>
<p>추가적으로 다음과 같은 부분을 언급 할 수 있다.</p>
<ul>
<li>경성(hard) 또는 연성(soft) 처리율 제한<br/>
<!-- -->경성 : 임계치를 절대 넘어설 수 없다<br/>
<!-- -->연성 : 잠시 임계치를 넘어설 수 있다.</li>
<li>다양한 계층에서 처리율 제한
이번에는 애플리케이션 계층에서의 제한만 살펴봄 ➡️ 다른 계층에서도 처리율 제한이 가능<br/>
<!-- -->네트워크 계층 처리율 제한으로 IP주소에 처리율 제한이 가능하다.</li>
<li>처리율 제한을 회피하는 방법 : 클라이언트를 개선하여 처리율 개선<!-- -->
<ol>
<li>캐시를 사용하여 호출 횟수 줄임</li>
<li>임계치를 이해시키고, 많은 메시지를 보내지 않도록 한다.</li>
<li>예외나 에러를 처리하는 코드로 예외인 상황에서 복구되도록</li>
<li>재시도 로직을 구현할 때 충분한 백오프 시간을 둔다.</li>
</ol>
</li>
</ul></div></main><footer class="w-full max-w-3xl items-center "><div class="h-28"></div> </footer></div><script src="/_next/static/chunks/webpack-b095ed2a5c5bf76b.js" async=""></script><script src="/_next/static/chunks/fd9d1056-5fc0659828b82348.js" async=""></script><script src="/_next/static/chunks/596-5f69a5936ae99734.js" async=""></script><script src="/_next/static/chunks/main-app-e8cf5a024458e18b.js" async=""></script><script>(self.__next_f=self.__next_f||[]).push([0])</script><script>self.__next_f.push([1,"1:HL[\"/_next/static/media/c9a5bc6a7c948fb0-s.p.woff2\",{\"as\":\"font\",\"type\":\"font/woff2\"}]\n2:HL[\"/_next/static/css/efb8fa6fa0f88240.css\",{\"as\":\"style\"}]\n0:\"$L3\"\n"])</script><script>self.__next_f.push([1,"4:I{\"id\":7948,\"chunks\":[\"272:static/chunks/webpack-b095ed2a5c5bf76b.js\",\"971:static/chunks/fd9d1056-5fc0659828b82348.js\",\"596:static/chunks/596-5f69a5936ae99734.js\"],\"name\":\"default\",\"async\":false}\n6:I{\"id\":6628,\"chunks\":[\"272:static/chunks/webpack-b095ed2a5c5bf76b.js\",\"971:static/chunks/fd9d1056-5fc0659828b82348.js\",\"596:static/chunks/596-5f69a5936ae99734.js\"],\"name\":\"\",\"async\":false}\n7:I{\"id\":6685,\"chunks\":[\"685:static/chunks/685-1c7543f9470b706b.js\",\"222:static/chunks/222-846c3dee61afe17f.js\",\"404:static"])</script><script>self.__next_f.push([1,"/chunks/app/blog/page-2b1879a4b7dd3b5f.js\"],\"name\":\"\",\"async\":false}\n8:I{\"id\":3222,\"chunks\":[\"685:static/chunks/685-1c7543f9470b706b.js\",\"222:static/chunks/222-846c3dee61afe17f.js\",\"404:static/chunks/app/blog/page-2b1879a4b7dd3b5f.js\"],\"name\":\"Image\",\"async\":false}\n9:I{\"id\":7767,\"chunks\":[\"272:static/chunks/webpack-b095ed2a5c5bf76b.js\",\"971:static/chunks/fd9d1056-5fc0659828b82348.js\",\"596:static/chunks/596-5f69a5936ae99734.js\"],\"name\":\"default\",\"async\":false}\na:I{\"id\":7920,\"chunks\":[\"272:static/chunks/webpa"])</script><script>self.__next_f.push([1,"ck-b095ed2a5c5bf76b.js\",\"971:static/chunks/fd9d1056-5fc0659828b82348.js\",\"596:static/chunks/596-5f69a5936ae99734.js\"],\"name\":\"default\",\"async\":false}\n"])</script><script>self.__next_f.push([1,"3:[[[\"$\",\"link\",\"0\",{\"rel\":\"stylesheet\",\"href\":\"/_next/static/css/efb8fa6fa0f88240.css\",\"precedence\":\"next\"}]],[\"$\",\"$L4\",null,{\"buildId\":\"HkFu9yovkSRgLjWBeCYHI\",\"assetPrefix\":\"\",\"initialCanonicalUrl\":\"/blog/LSS4\",\"initialTree\":[\"\",{\"children\":[\"blog\",{\"children\":[[\"slug\",\"LSS4\",\"d\"],{\"children\":[\"__PAGE__?{\\\"slug\\\":\\\"LSS4\\\"}\",{}]}]}]},\"$undefined\",\"$undefined\",true],\"initialHead\":\"$L5\",\"globalErrorComponent\":\"$6\",\"children\":[null,[\"$\",\"html\",null,{\"lang\":\"kr\",\"children\":[\"$\",\"body\",null,{\"className\":\"__className_e66fe9\",\"children\":[\"$\",\"div\",null,{\"className\":\"w-full flex flex-col items-center p-3\",\"children\":[null,[\"$\",\"header\",null,{\"className\":\"w-full max-w-3xl flex flex-row justify-between items-center my-1\",\"children\":[[\"$\",\"$L7\",null,{\"href\":\"/\",\"className\":\"flex flex-row items-center\",\"children\":[[\"$\",\"$L8\",null,{\"src\":\"/logo.png\",\"alt\":\"로고\",\"width\":30,\"height\":30,\"objectFit\":\"cover\",\"className\":\"rounded-full\"}],[\"$\",\"span\",null,{\"className\":\"mx-2 font-semibold text-lg\",\"children\":\"jiohh blog\"}]]}],[\"$\",\"nav\",null,{\"children\":[[\"$\",\"$L7\",\"Home\",{\"href\":\"/\",\"className\":\"mr-5 \",\"children\":\"Home\"}],[\"$\",\"$L7\",\"Blog\",{\"href\":\"/blog\",\"className\":\"mr-5 \",\"children\":\"Blog\"}],[\"$\",\"$L7\",\"Category\",{\"href\":\"/category\",\"className\":\"mr-5 \",\"children\":\"Category\"}]]}]]}],[\"$\",\"main\",null,{\"className\":\"w-full max-w-3xl\",\"children\":[\"$\",\"$L9\",null,{\"parallelRouterKey\":\"children\",\"segmentPath\":[\"children\"],\"error\":\"$undefined\",\"errorStyles\":\"$undefined\",\"loading\":\"$undefined\",\"loadingStyles\":\"$undefined\",\"hasLoading\":false,\"template\":[\"$\",\"$La\",null,{}],\"templateStyles\":\"$undefined\",\"notFound\":[[\"$\",\"title\",null,{\"children\":\"404: This page could not be found.\"}],[\"$\",\"div\",null,{\"style\":{\"fontFamily\":\"system-ui,\\\"Segoe UI\\\",Roboto,Helvetica,Arial,sans-serif,\\\"Apple Color Emoji\\\",\\\"Segoe UI Emoji\\\"\",\"height\":\"100vh\",\"textAlign\":\"center\",\"display\":\"flex\",\"flexDirection\":\"column\",\"alignItems\":\"center\",\"justifyContent\":\"center\"},\"children\":[\"$\",\"div\",null,{\"children\":[[\"$\",\"style\",null,{\"dangerouslySetInnerHTML\":{\"__html\":\"body{color:#000;background:#fff;margin:0}.next-error-h1{border-right:1px solid rgba(0,0,0,.3)}@media (prefers-color-scheme:dark){body{color:#fff;background:#000}.next-error-h1{border-right:1px solid rgba(255,255,255,.3)}}\"}}],[\"$\",\"h1\",null,{\"className\":\"next-error-h1\",\"style\":{\"display\":\"inline-block\",\"margin\":\"0 20px 0 0\",\"padding\":\"0 23px 0 0\",\"fontSize\":24,\"fontWeight\":500,\"verticalAlign\":\"top\",\"lineHeight\":\"49px\"},\"children\":\"404\"}],[\"$\",\"div\",null,{\"style\":{\"display\":\"inline-block\"},\"children\":[\"$\",\"h2\",null,{\"style\":{\"fontSize\":14,\"fontWeight\":400,\"lineHeight\":\"49px\",\"margin\":0},\"children\":\"This page could not be found.\"}]}]]}]}]],\"notFoundStyles\":\"$undefined\",\"childProp\":{\"current\":[\"$\",\"$L9\",null,{\"parallelRouterKey\":\"children\",\"segmentPath\":[\"children\",\"blog\",\"children\"],\"error\":\"$undefined\",\"errorStyles\":\"$undefined\",\"loading\":\"$undefined\",\"loadingStyles\":\"$undefined\",\"hasLoading\":false,\"template\":[\"$\",\"$La\",null,{}],\"templateStyles\":\"$undefined\",\"notFound\":\"$undefined\",\"notFoundStyles\":\"$undefined\",\"childProp\":{\"current\":[\"$\",\"$L9\",null,{\"parallelRouterKey\":\"children\",\"segmentPath\":[\"children\",\"blog\",\"children\",[\"slug\",\"LSS4\",\"d\"],\"children\"],\"error\":\"$undefined\",\"errorStyles\":\"$undefined\",\"loading\":\"$undefined\",\"loadingStyles\":\"$undefined\",\"hasLoading\":false,\"template\":[\"$\",\"$La\",null,{}],\"templateStyles\":\"$undefined\",\"notFound\":\"$undefined\",\"notFoundStyles\":\"$undefined\",\"childProp\":{\"current\":[\"$Lb\",[\"$\",\"div\",null,{\"className\":\"mt-10 prose\",\"children\":[[\"$\",\"h1\",null,{\"className\":\"\",\"children\":\"4장 - 처리율 제한 장치의 설계\"}],[[\"$\",\"h2\",null,{\"children\":\"목표\"}],\"\\n\",[\"$\",\"p\",null,{\"children\":[\"처리율 제한 장치 : 클라이언트 또는 서비스가 보내는 트래픽의 처리율을 제어하기 위한 장치\",[\"$\",\"br\",null,{}],\"\\n\",\"임계치를 넘어선 호출의 경우 처리가 중단(block)된다.\"]}],\"\\n\",[\"$\",\"p\",null,{\"children\":\"처리율 제한 장치의 사용에 대한 장점\"}],\"\\n\",[\"$\",\"ul\",null,{\"children\":[\"\\n\",[\"$\",\"li\",null,{\"children\":\"Dos공격에 의한 자원 고갈을 방지 할 수 있다.\"}],\"\\n\",[\"$\",\"li\",null,{\"children\":[\"비용을 절감한다. 서버를 많이 두지 않아도되고 우선 순위가 높은 API에 대한 더 많은 자원을 할당할 수 있다.\",[\"$\",\"br\",null,{}],\"\\n\",\"API를 사용하고 있는 서비스의 경우 횟수 제한으로 인한 비용절감 효율이 증가한다.\"]}],\"\\n\",[\"$\",\"li\",null,{\"children\":\"서버 과부하를 막는다. bot에서 오는 트래픽, 사용자의 잘못된 이용으로 인한 트래픽을 줄임으로 과부하를 막는다.\"}],\"\\n\"]}],\"\\n\",[\"$\",\"p\",null,{\"children\":\"이러한 처리율 제한 장치 설계에 대해 알아보자\"}],\"\\n\",[\"$\",\"h2\",null,{\"children\":\"1단계 문제 이해 및 설계 범위 확정\"}],\"\\n\",[\"$\",\"p\",null,{\"children\":[\"면접관과 소통을 통해 어떤 제한 장치를 구현해야 하는지 분명히 함으로 \",[\"$\",\"strong\",null,{\"children\":\"처리율 제한 장치의 알고리즘을 선택\"}],\" 할 수 있다.\"]}],\"\\n\",[\"$\",\"p\",null,{\"children\":\"다음 시스템 요구사항을 얻어낼 수 있다.\"}],\"\\n\",[\"$\",\"ul\",null,{\"children\":[\"\\n\",[\"$\",\"li\",null,{\"children\":\"설정된 처리율을 초과하는 요청은 정확하게 제한한다.\"}],\"\\n\",[\"$\",\"li\",null,{\"children\":\"낮은 응답시간 : 처리율 제한 장치로 HTTP 응답시간에 영향을 주어서는 곤란하다.\"}],\"\\n\",[\"$\",\"li\",null,{\"children\":\"메모리는 가능한 적게 사용\"}],\"\\n\",[\"$\",\"li\",null,{\"children\":\"분산형 처리율 제한 : 처리율 제한 장치를 여러서버나 프로세스에서 공유할 수 있어야 한다.\"}],\"\\n\",[\"$\",\"li\",null,{\"children\":\"예외처리 : 요청이 제한되었을때 사용자에게 분명히 보여주어야 한다.\"}],\"\\n\",[\"$\",\"li\",null,{\"children\":\"높은 결함 감내성 : 제한 장치에 장애가 생기더라도 전체 시스템에 영향을 주어서는 안된다.\"}],\"\\n\"]}],\"\\n\",[\"$\",\"h2\",null,{\"children\":\"2단계 개략적 설계안 제시 및 동의 구하기\"}],\"\\n\",[\"$\",\"h3\",null,{\"children\":\"처리율 제한 장치는 어디에 둘 것인가?\"}],\"\\n\",[\"$\",\"h4\",null,{\"children\":\"클라이언트\"}],\"\\n\",[\"$\",\"p\",null,{\"children\":\"클라이언트 요청은 쉽게 위변조가 가능해 처리율 제한을 안정적으로 걸 수 있는 환경이 아님\"}],\"\\n\",[\"$\",\"h4\",null,{\"children\":\"서버\"}],\"\\n\",[\"$\",\"ol\",null,{\"children\":[\"\\n\",[\"$\",\"li\",null,{\"children\":\"API 서버가 처리율 제한 장치역할을 같이하는 경우\"}],\"\\n\",[\"$\",\"li\",null,{\"children\":\"처리율 제한 미들웨어를 만들어 API서버로 가는 요청을 통제하도록하는 경우\\n클라우드 마이크로서비스의 경우 해당 방식은 보통 API 게이트웨이라 불리는 컴포넌트에 구현\"}],\"\\n\"]}],\"\\n\",[\"$\",\"p\",null,{\"children\":\"처리율 제한 장치는 어디에 두어야하는 것에 정답은 없다. 기술스택, 인력, 우선순위, 목표에 따라 달라진다.\"}],\"\\n\",[\"$\",\"ul\",null,{\"children\":[\"\\n\",[\"$\",\"li\",null,{\"children\":\"기술 스택을 점검하라. 현재 사용하는 프로그래밍 언어가 서버 측 구현을 지원하기 충분할 정도로 효율이 높은지 확인하라.\"}],\"\\n\",[\"$\",\"li\",null,{\"children\":\"필요에 맞는 처리율 제한 알고리즘을 찾아라, 서버에서 구현한다면 선택가능하나 제 3 사업자가 제공하는 게이트웨이를 사용하면 선택지는 제한된다.\"}],\"\\n\",[\"$\",\"li\",null,{\"children\":\"마이크로서비스에 기반하고 있고, 사용자 인증/IP 허용목록 관리 등의 처리로 API 게이트웨이를 설계에 포함시켰다면 처리율 제한 기능도 게이트 웨이에 포함시켜야 할 수도 있다.\"}],\"\\n\",[\"$\",\"li\",null,{\"children\":\"처리율 제한 서비스는 직접 만드는데 시간이 든다, 사용 API 게이트웨이를 쓰는 것이 바람직 할 수도 있다.\"}],\"\\n\"]}],\"\\n\",[\"$\",\"h3\",null,{\"children\":\"처리율 제한 알고리즘\"}],\"\\n\",[\"$\",\"h4\",null,{\"children\":\"토큰 버킷 알고리즘\"}],\"\\n\",[\"$\",\"p\",null,{\"children\":\"간단한 알고리즘으로 보편적으로 사용한다. 아마존,스트라이프에서 사용\"}],\"\\n\",[\"$\",\"p\",null,{\"children\":\"토큰 버킷은 지정된 용량을 갖는 컨테이너이며 사전 설정된 양의 토큰이 주기적으로 채워진다.\"}],\"\\n\",[\"$\",\"p\",null,{\"children\":\"각 요청은 처리 될때마다 하나의 토큰을 사용한다\"}],\"\\n\",[\"$\",\"ul\",null,{\"children\":[\"\\n\",[\"$\",\"li\",null,{\"children\":\"충분한 토큰이 있는 경우 하나의 토큰을 꺼낸 후 요청을 시스템에 전달\"}],\"\\n\",[\"$\",\"li\",null,{\"children\":\"충분한 토큰이 없는 경우 해당 요청은 버려짐\"}],\"\\n\"]}],\"\\n\",[\"$\",\"img\",null,{\"src\":\"/images/LSS/bucketargo.png\",\"width\":\"100%\",\"height\":\"100%\"}],\"\\n\",[\"$\",\"p\",null,{\"children\":\"두개의 인자를 받는다.\"}],\"\\n\",[\"$\",\"ul\",null,{\"children\":[\"\\n\",[\"$\",\"li\",null,{\"children\":\"버킷 크기 : 버킷에 담을 수 있는 토큰의 최대 개수\"}],\"\\n\",[\"$\",\"li\",null,{\"children\":\"토큰 공급률 : 초당 몇 개의 토큰이 버킷에 공급되는가?\"}],\"\\n\"]}],\"\\n\",[\"$\",\"p\",null,{\"children\":\"버킷은 몇 개나 사용해야하는지는 공급 제한 규칙에 따라 달라진다.\"}],\"\\n\",[\"$\",\"ul\",null,{\"children\":[\"\\n\",[\"$\",\"li\",null,{\"children\":[\"통상적으로, API 엔드포인트마다 별도의 버킷을 둔다.\",[\"$\",\"br\",null,{}],\"\\n\",\"ex) 하루에 한번 포스팅, 친추추가는 150명까지, 좋아요는 다섯번 ➡️ 사용자마다 3개의 버킷 필요\"]}],\"\\n\",[\"$\",\"li\",null,{\"children\":\"IP 주소별로 처리율 제한 ➡️ IP주소마다 버킷\"}],\"\\n\",[\"$\",\"li\",null,{\"children\":\"시스템 처리율을 초당 10,000개 요청 제한하고 싶으면, 모든 요청이 하나의 버킷을 공유\"}],\"\\n\"]}],\"\\n\",[\"$\",\"p\",null,{\"children\":\"장점\"}],\"\\n\",[\"$\",\"ul\",null,{\"children\":[\"\\n\",[\"$\",\"li\",null,{\"children\":\"구현이 쉬움\"}],\"\\n\",[\"$\",\"li\",null,{\"children\":\"메모리 사용 측면에서 효율적\"}],\"\\n\",[\"$\",\"li\",null,{\"children\":\"짤은 시간에 집중되는 트래픽에서도 처리 가능\"}],\"\\n\"]}],\"\\n\",[\"$\",\"p\",null,{\"children\":\"단점\"}],\"\\n\",[\"$\",\"ul\",null,{\"children\":[\"\\n\",[\"$\",\"li\",null,{\"children\":\"버킷크기와 토큰 공급률을 적당한 값에 맞추는 것이 어려움\"}],\"\\n\"]}],\"\\n\",[\"$\",\"h4\",null,{\"children\":\"누출 버킷 알고리즘\"}],\"\\n\",[\"$\",\"p\",null,{\"children\":[\"토큰 버킷 알고리즘과 비슷 - 요청 처리율이 고정되어 있음\",[\"$\",\"br\",null,{}],\"\\n\",\"FIFO큐로 구현한다.\"]}],\"\\n\",[\"$\",\"img\",null,{\"src\":\"/images/LSS/leakybucket.png\",\"width\":\"100%\",\"height\":\"100%\"}],\"\\n\",[\"$\",\"ul\",null,{\"children\":[\"\\n\",[\"$\",\"li\",null,{\"children\":\"요청이 도착하면 큐가 가득 차있는지 확인 후, 빈자리가 있는 경우 큐에 넣는다.\"}],\"\\n\"]}],\"\\n\",[\"$\",\"p\",null,{\"children\":\"두 개의 인자를 사용한다.\"}],\"\\n\",[\"$\",\"ul\",null,{\"children\":[\"\\n\",[\"$\",\"li\",null,{\"children\":\"버킷 크기 : 큐 사이즈와 같은 값\"}],\"\\n\",[\"$\",\"li\",null,{\"children\":\"처리율 : 지정된 시간당 몇 개의 항목을 처리할지 지정하는 값, 초 단위로 표현\"}],\"\\n\"]}],\"\\n\",[\"$\",\"p\",null,{\"children\":\"장점\"}],\"\\n\",[\"$\",\"ul\",null,{\"children\":[\"\\n\",[\"$\",\"li\",null,{\"children\":\"큐의 크기가 제한되어 있어 메모리 사용량 측면에서 효율적\"}],\"\\n\",[\"$\",\"li\",null,{\"children\":\"고정된 처리율을 갖고 있기 때문에 안정적 출력에 적합\"}],\"\\n\"]}],\"\\n\",[\"$\",\"p\",null,{\"children\":\"단점\"}],\"\\n\",[\"$\",\"ul\",null,{\"children\":[\"\\n\",[\"$\",\"li\",null,{\"children\":\"단시간에 트래픽이 몰리는 경우, 오래된 요청이 쌓여 최신요청들은 버려지게됨\"}],\"\\n\",[\"$\",\"li\",null,{\"children\":\"두개의 인자 설정이 어려움\"}],\"\\n\"]}],\"\\n\",[\"$\",\"h4\",null,{\"children\":\"고정 윈도 카운터 알고리즘\"}],\"\\n\",[\"$\",\"ul\",null,{\"children\":[\"\\n\",[\"$\",\"li\",null,{\"children\":\"타임라인을 고정된 간격의 윈도로 나누고, 각 윈도우 마다 카운터(counter)를 붙인다.\"}],\"\\n\",[\"$\",\"li\",null,{\"children\":\"요청이 접수될 때마다 이 카운터의 값은 1씩 증가한다.\"}],\"\\n\",[\"$\",\"li\",null,{\"children\":\"카운터의 값이 임계치에 도달하면 새로운 요청은 새 윈도가 열릴 때까지 버려진다.\"}],\"\\n\"]}],\"\\n\",[\"$\",\"img\",null,{\"src\":\"/images/LSS/fixed-window-counter.png\",\"width\":\"100%\",\"height\":\"100%\"}],\"\\n\",[\"$\",\"ul\",null,{\"children\":[\"\\n\",[\"$\",\"li\",null,{\"children\":\"해당 시스템은 초당 3개까지의 요청만 허용한다.\"}],\"\\n\"]}],\"\\n\",[\"$\",\"img\",null,{\"src\":\"/images/LSS/fixed-window-counter-problem.png\",\"width\":\"100%\",\"height\":\"100%\"}],\"\\n\",[\"$\",\"ul\",null,{\"children\":[\"\\n\",[\"$\",\"li\",null,{\"children\":\"초당 5개의 요청만 허용하는 시스템\"}],\"\\n\",[\"$\",\"li\",null,{\"children\":\"2:00:00 ~ 2:01:00 5개의 요청\"}],\"\\n\",[\"$\",\"li\",null,{\"children\":\"2:01:00 ~ 2:02:00 5개의 요청\"}],\"\\n\",[\"$\",\"li\",null,{\"children\":\"그러나 윈도우를 조금 옮겨 2:00:30 ~ 2:01:30으로 보았을 떄 10개의 요청이 처리됨\"}],\"\\n\"]}],\"\\n\",[\"$\",\"p\",null,{\"children\":\"윈도의 경계 부근에 순간적으로 많은 트래픽이 집중될 경우 윈도에 할당된 양보다 더 많은 요청이 처리될 수 있다.\"}],\"\\n\",[\"$\",\"p\",null,{\"children\":\"장점\"}],\"\\n\",[\"$\",\"ul\",null,{\"children\":[\"\\n\",[\"$\",\"li\",null,{\"children\":\"메모리 효율이 좋다\"}],\"\\n\",[\"$\",\"li\",null,{\"children\":\"이해하기 쉽다.\"}],\"\\n\",[\"$\",\"li\",null,{\"children\":\"윈도우가 닫히는 시점에 카운터 초기화 ➡️ 특정한 트래픽 패턴을 처리하기에 적합\"}],\"\\n\"]}],\"\\n\",[\"$\",\"p\",null,{\"children\":\"단점\"}],\"\\n\",[\"$\",\"ul\",null,{\"children\":[\"\\n\",[\"$\",\"li\",null,{\"children\":\"경계부분에 몰릴 경우, 시스템의 처리 한도보다 많은 양의 요청을 처리하게 된다.\"}],\"\\n\"]}],\"\\n\",[\"$\",\"h4\",null,{\"children\":\"이동 윈도 로깅 알고리즘\"}],\"\\n\",[\"$\",\"p\",null,{\"children\":[\"이동 윈도 알고리즘은 고정 윈도 카운터 알고리즘의 경계 부근의 트래픽 집중 문제를 해결한다.\",[\"$\",\"br\",null,{}],\"\\n\",\"요청의 타임스탬프를 추적하는 방식을 사용한다. 타임스탬프 데이터는 보통 Redis의 정렬 집합 같은 캐시에 보관한다.\"]}],\"\\n\",[\"$\",\"img\",null,{\"src\":\"/images/LSS/sliding-window-log.png\",\"width\":\"100%\",\"height\":\"100%\"}],\"\\n\",[\"$\",\"ul\",null,{\"children\":[\"\\n\",[\"$\",\"li\",null,{\"children\":\"새요청이 오면 만료된 타임스탬프는 제거한다. 만료된 타임스탬프는 그 값이 현재\\n윈도의 시작 지점보다 오래된 타임스탬프를 말한다.\"}],\"\\n\",[\"$\",\"li\",null,{\"children\":\"새요청의 타임스탬프를 로그에 추가한다.\"}],\"\\n\",[\"$\",\"li\",null,{\"children\":\"로그의 크기가 허용치보다 크면 처리를 거부한다.\"}],\"\\n\"]}],\"\\n\",[\"$\",\"p\",null,{\"children\":\"장점\"}],\"\\n\",[\"$\",\"ul\",null,{\"children\":[\"\\n\",[\"$\",\"li\",null,{\"children\":\"어느 순간의 윈도를 보더라도, 허용되는 요청의 개수는 시스템의 처리율 한도를 넘지 않는다.\"}],\"\\n\"]}],\"\\n\",[\"$\",\"p\",null,{\"children\":\"단점\"}],\"\\n\",[\"$\",\"ul\",null,{\"children\":[\"\\n\",[\"$\",\"li\",null,{\"children\":\"다량의 메모리 사용, 거부된 요청의 타임스탬프도 보관하기 때문이다.\"}],\"\\n\"]}],\"\\n\",[\"$\",\"h4\",null,{\"children\":\"이동 윈도 카운터 알고리즘\"}],\"\\n\",[\"$\",\"p\",null,{\"children\":\"고정 윈도 카운터 알고리즘 + 이동 윈도 로깅 알고리즘 = 이동 윈도 카운터 알고리즘\"}],\"\\n\",[\"$\",\"img\",null,{\"src\":\"/images/LSS/sliding-window-counter.png\",\"width\":\"70%\",\"height\":\"100%\"}],\"\\n\",[\"$\",\"p\",null,{\"children\":\"분당 7개의 요청 한도에서, 이전 1분동안 5개의 요청, 현재 1분 동안 3개의 요청이 오는 상황이다.\"}],\"\\n\",[\"$\",\"p\",null,{\"children\":\"현재 1분의 30% 기점에 도착한 새 요청의 경우, 현재 윈도에 몇 개의 요청이 온 것으로 보고 처리해야할까?\"}],\"\\n\",[\"$\",\"ul\",null,{\"children\":[\"\\n\",[\"$\",\"li\",null,{\"children\":\"현재 1분간 요청 수 + 직전 1분간 요청수 * 이동 윈도와 직전 1분이 겹치는 비율\"}],\"\\n\",[\"$\",\"li\",null,{\"children\":\"3 + 5 * 70% = 6.5, 내림하여 6\"}],\"\\n\"]}],\"\\n\",[\"$\",\"p\",null,{\"children\":\"장점\"}],\"\\n\",[\"$\",\"ul\",null,{\"children\":[\"\\n\",[\"$\",\"li\",null,{\"children\":\"이전 시간대의 평균 처리율에 따라 현재 윈도의 상태를 계산하므로 짧은 시간에 몰리는 트래픽에도 잘 대응\"}],\"\\n\",[\"$\",\"li\",null,{\"children\":\"메모리 효율이 좋다.\"}],\"\\n\"]}],\"\\n\",[\"$\",\"p\",null,{\"children\":\"단점\"}],\"\\n\",[\"$\",\"ul\",null,{\"children\":[\"\\n\",[\"$\",\"li\",null,{\"children\":\"직전 시간대에 도착한 요청이 균등하게 분포되어 있다고 가정한 상태에서 추정치를 계산하기 때문에 다소 느슨하다.(잘못된 처리 0.003%로 심각하지 않음)\"}],\"\\n\"]}],\"\\n\",[\"$\",\"h4\",null,{\"children\":\"개략적인 아키텍쳐\"}],\"\\n\",[\"$\",\"p\",null,{\"children\":\"기본 아이디어는 추적할 수 있는 카운터를 추적 대상별로 두고 거부또는 허가하는 것이다.\\n이때 카운터에는 디스크 접근 떄문에 느리기 때문에 메모리 상에서 동작하는 Redis와 같은 메모리 기반 저장장치를 사용한다.\"}],\"\\n\",[\"$\",\"p\",null,{\"children\":\"메모리 기반 저장장치는 두개의 명령어를 지원한다.\"}],\"\\n\",[\"$\",\"ul\",null,{\"children\":[\"\\n\",[\"$\",\"li\",null,{\"children\":\"INCR : 메모리의 저장된 카운터의 값을 1만큼 증가시킨다.\"}],\"\\n\",[\"$\",\"li\",null,{\"children\":\"EXPIRE : 카운터에 타임아웃 값을 설정한다. 설정시간이 되면 카운터는 자동으로 삭제된다.\"}],\"\\n\"]}],\"\\n\",[\"$\",\"img\",null,{\"src\":\"/images/LSS/Redis.png\",\"width\":\"100%\",\"height\":\"100%\"}],\"\\n\",[\"$\",\"ul\",null,{\"children\":[\"\\n\",[\"$\",\"li\",null,{\"children\":\"요청이 오면 처리율 제한 미들웨어는 레디스의 지정 버킷에서 카운터를 가져와 한도에 도달했는지 아닌지를\\n검사한다.\"}],\"\\n\",[\"$\",\"li\",null,{\"children\":\"한도에 도달하지 않았다면 요청은 API서버로 전달된다. 미들웨어는 카운터의 값을 증가시킨 후 다시 레디스에 저장한다.\"}],\"\\n\"]}],\"\\n\",[\"$\",\"h2\",null,{\"children\":\"상세 설계\"}],\"\\n\",[\"$\",\"ul\",null,{\"children\":[\"\\n\",[\"$\",\"li\",null,{\"children\":\"처리율 제한 규칙은 어떻게 만들어지고 어디에 저장되는가?\"}],\"\\n\",[\"$\",\"li\",null,{\"children\":\"처리가 제한된 요청들은 어떻게 처리되는가?\"}],\"\\n\"]}],\"\\n\",[\"$\",\"p\",null,{\"children\":\"위의 두 사항에 대해 알아보자\"}],\"\\n\",[\"$\",\"h3\",null,{\"children\":\"처리율 제한 규칙\"}],\"\\n\",[\"$\",\"ul\",null,{\"children\":[\"\\n\",[\"$\",\"li\",null,{\"children\":\"마케팅 메시지의 최대치를 하루 5개로 제한\"}],\"\\n\",[\"$\",\"li\",null,{\"children\":\"분당 로그인 횟수를 5개로 제한\"}],\"\\n\"]}],\"\\n\",[\"$\",\"p\",null,{\"children\":\"리프트의 경우 다음과 같이 제한하며, 설정파일 형태로 디스크에 저장된다.\"}],\"\\n\",[\"$\",\"h3\",null,{\"children\":\"처리율 한도 초과 트래픽\"}],\"\\n\",[\"$\",\"p\",null,{\"children\":\"한도 제한에 거릴 경우 HTTP 429 응답을 보낸다.\"}],\"\\n\",[\"$\",\"ul\",null,{\"children\":[\"\\n\",[\"$\",\"li\",null,{\"children\":\"X-Ratelimit-Remaining : 윈도 내에 남은 처리 가능 요청의 수\"}],\"\\n\",[\"$\",\"li\",null,{\"children\":\"X-Ratelimit-Limit : 매 윈도마다 클라이언트가 전송할 수 있는 요청의 수\"}],\"\\n\",[\"$\",\"li\",null,{\"children\":\"X-Ratelimit-Retry-After : 한도 제한에 걸리지 않으려면 몇 초 뒤에 요청을 다시 보내야하는지 알림\"}],\"\\n\"]}],\"\\n\",[\"$\",\"p\",null,{\"children\":\"자기 요청이 처리율 제한에 걸리기까지 얼마나 많은 요청을 보낼 수 있는지는 HTTP 요청헤더로 확인 가능하다.\"}],\"\\n\",[\"$\",\"h3\",null,{\"children\":\"상세 설계\"}],\"\\n\",[\"$\",\"img\",null,{\"src\":\"/images/LSS/detail.png\",\"width\":\"100%\",\"height\":\"100%\"}],\"\\n\",[\"$\",\"p\",null,{\"children\":\"다음은 상세 설계 도면이다.\"}],\"\\n\",[\"$\",\"h3\",null,{\"children\":\"분산 환경에서의 처리율 제한 장치의 구현\"}],\"\\n\",[\"$\",\"p\",null,{\"children\":\"경쟁조건, 동기화 두가지 문제를 풀어야한다.\"}],\"\\n\",[\"$\",\"h4\",null,{\"children\":\"경쟁조건\"}],\"\\n\",[\"$\",\"img\",null,{\"src\":\"/images/LSS/trace.png\",\"width\":\"100%\",\"height\":\"100%\"}],\"\\n\",[\"$\",\"p\",null,{\"children\":\"경쟁 조건 문제를 해결하는 가장 널리 알려진 해결책은 Lock(락)이다.\\n하지만 락은 시스템 성능을 떨어뜨림, 해결책으로는 두가지 방법이 있음\"}],\"\\n\",[\"$\",\"ul\",null,{\"children\":[\"\\n\",[\"$\",\"li\",null,{\"children\":\"루아 스크립트\"}],\"\\n\",[\"$\",\"li\",null,{\"children\":\"정렬집합이라 불리는 레디스 자료구조\"}],\"\\n\"]}],\"\\n\",[\"$\",\"h3\",null,{\"children\":\"동기화 이슈\"}],\"\\n\",[\"$\",\"p\",null,{\"children\":[\"처리율 제한 장치를 여러 대 두게 되면 동기화가 필요해진다.\",[\"$\",\"br\",null,{}],\"\\n\",\"장치간의 처리율 제한에 대한 정보가 공유되지않아 올바르게 수행 할 수 없다.\"]}],\"\\n\",[\"$\",\"img\",null,{\"src\":\"/images/LSS/center-redis.png\",\"width\":\"100%\",\"height\":\"100%\"}],\"\\n\",[\"$\",\"p\",null,{\"children\":\"레디스와 같은 중앙 집중형 데이터 저장소를 쓰는 것으로 해결\"}],\"\\n\",[\"$\",\"h3\",null,{\"children\":\"성능 최적화\"}],\"\\n\",[\"$\",\"ol\",null,{\"children\":[\"\\n\",[\"$\",\"li\",null,{\"children\":\"edge server을 이용하여 가까운 데이터센터를 지원하여 지연시간을 줄임으로 성능 최적화\"}],\"\\n\",[\"$\",\"li\",null,{\"children\":\"제한 장치 간에 데이터를 동기화 할때 최종 일관성 모델을 사용\"}],\"\\n\"]}],\"\\n\",[\"$\",\"h3\",null,{\"children\":\"모니터링\"}],\"\\n\",[\"$\",\"p\",null,{\"children\":\"모니터링을 통해 알고리즘, 제한 규칙이 효과적인지 확인할 수 있다.\"}],\"\\n\",[\"$\",\"h2\",null,{\"children\":\"4단계 마무리\"}],\"\\n\",[\"$\",\"p\",null,{\"children\":\"추가적으로 다음과 같은 부분을 언급 할 수 있다.\"}],\"\\n\",[\"$\",\"ul\",null,{\"children\":[\"\\n\",[\"$\",\"li\",null,{\"children\":[\"경성(hard) 또는 연성(soft) 처리율 제한\",[\"$\",\"br\",null,{}],\"\\n\",\"경성 : 임계치를 절대 넘어설 수 없다\",[\"$\",\"br\",null,{}],\"\\n\",\"연성 : 잠시 임계치를 넘어설 수 있다.\"]}],\"\\n\",[\"$\",\"li\",null,{\"children\":[\"다양한 계층에서 처리율 제한\\n이번에는 애플리케이션 계층에서의 제한만 살펴봄 ➡️ 다른 계층에서도 처리율 제한이 가능\",[\"$\",\"br\",null,{}],\"\\n\",\"네트워크 계층 처리율 제한으로 IP주소에 처리율 제한이 가능하다.\"]}],\"\\n\",[\"$\",\"li\",null,{\"children\":[\"처리율 제한을 회피하는 방법 : 클라이언트를 개선하여 처리율 개선\",\"\\n\",[\"$\",\"ol\",null,{\"children\":[\"\\n\",[\"$\",\"li\",null,{\"children\":\"캐시를 사용하여 호출 횟수 줄임\"}],\"\\n\",[\"$\",\"li\",null,{\"children\":\"임계치를 이해시키고, 많은 메시지를 보내지 않도록 한다.\"}],\"\\n\",[\"$\",\"li\",null,{\"children\":\"예외나 에러를 처리하는 코드로 예외인 상황에서 복구되도록\"}],\"\\n\",[\"$\",\"li\",null,{\"children\":\"재시도 로직을 구현할 때 충분한 백오프 시간을 둔다.\"}],\"\\n\"]}],\"\\n\"]}],\"\\n\"]}]]]}],null],\"segment\":\"__PAGE__?{\\\"slug\\\":\\\"LSS4\\\"}\"},\"styles\":[]}],\"segment\":[\"slug\",\"LSS4\",\"d\"]},\"styles\":[]}],\"segment\":\"blog\"},\"styles\":[]}]}],[\"$\",\"footer\",null,{\"className\":\"w-full max-w-3xl items-center \",\"children\":[[\"$\",\"div\",null,{\"className\":\"h-28\"}],\" \"]}]]}]}]}],null]}]]\n"])</script><script>self.__next_f.push([1,"5:[[\"$\",\"meta\",\"0\",{\"charSet\":\"utf-8\"}],[\"$\",\"title\",\"1\",{\"children\":\"Create Next App\"}],[\"$\",\"meta\",\"2\",{\"name\":\"description\",\"content\":\"Generated by create next app\"}],[\"$\",\"meta\",\"3\",{\"name\":\"viewport\",\"content\":\"width=device-width, initial-scale=1\"}],[\"$\",\"link\",\"4\",{\"rel\":\"icon\",\"href\":\"/favicon.ico\",\"type\":\"image/x-icon\",\"sizes\":\"16x16\"}],[\"$\",\"meta\",\"5\",{\"name\":\"next-size-adjust\"}]]\nb:null\n"])</script></body></html>